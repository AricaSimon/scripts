//------------------------------------------------
//--- 010 Editor v10.0 Binary Template
//
//      File: MBR.bt
//   Authors: Jordan Kimball
//   Version: 1.2
//   Purpose: Decodes MBR records
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//     Notes: There is probibally a better way to 
//            write this but this works and im to
//            lazy to rewrite it :P
//------------------------------------------------

typedef struct{
    local string part1_s;
    local string s;
    local string temp = "";

    byte part1[4] <format=hex>;
    SPrintf(temp,"%X", part1[3]);
    part1_s+=SubStr(temp,6);
    temp="";
    SPrintf(temp,"%X", part1[2]);
    part1_s+=SubStr(temp,6);
    temp="";
    SPrintf(temp,"%X", part1[1]);
    part1_s+=SubStr(temp,6);
    temp="";
    SPrintf(temp,"%X", part1[0]);
    part1_s+=SubStr(temp,6);
    temp="";
    s+="-";

    byte part2[2] <format=hex>;
    SPrintf(temp,"%X", part2[1]);
    s+=SubStr(temp,6);
    SPrintf(temp,"%X", part2[0]);
    s+=SubStr(temp,6);
    s+="-";

    byte part3[2] <format=hex>;
    SPrintf(temp,"%X", part3[1]);
    s+=SubStr(temp,6);
    SPrintf(temp,"%X", part3[0]);
    s+=SubStr(temp,6);

    
    byte part4[2] <format=hex>;
    byte part5[6] <format=hex>;
    //Printf("%X %X %X %X",part1[3],part1[2],part1[1],part1[0]);
    //local string GUID +=""+part1[3]+part1[2]+part1[1]+part1[0];
    LittleEndian();
} GUID;

typedef struct{
    char signature[8]<fgcolor=cLtRed>;
    uint revision<fgcolor=cLtGreen>;
    uint header_size<fgcolor=cLtBlue>;
    uint crc32<fgcolor=cAqua>;
    uint reserved<fgcolor=cLtPurple>;
    uint64 current_lba<fgcolor=cLtYellow>;
    uint64 backup_lba<fgcolor=cLtRed>;
    uint64 first_usable_lba<fgcolor=cLtGreen>;
    uint64 last_usable_lba<fgcolor=cLtBlue>;
    GUID disk_guid<fgcolor=cAqua>;
    uint64 lba_partiton_entry_array<fgcolor=cLtPurple>;
    uint total_partition_slots<fgcolor=cLtYellow>;
    uint size_partition_slot<fgcolor=cLtRed>;
    uint crc32_partition_arrayl<fgcolor=cLtGreen>;
    byte reserved2[420]<fgcolor=cLtBlue>;
} GPT_Header;



typedef struct {
    GUID part_type_guid<fgcolor=cLtRed>;
    GUID part_unique_guid<fgcolor=cLtGreen>;
    uint64 start_lba<fgcolor=cLtBlue>;
    uint64 end_lba<fgcolor=cLtPurple>;
    local uint64 size = end_lba-start_lba+1;
    uint64 attributes<fgcolor=cLtYellow>;
    //defines unicode string
    wchar_t name[36]<fgcolor=cAqua>;
    
} GPT_Partition_Entry;

typedef string F_GPT <read=F_GPT_READ, write=F_GPT_WRITE>;

string F_GPT_READ(byte b[]){
    //SPrintf
}

void readGPT(int offset){
    LittleEndian();
    FSeek(offset);
    GPT_Header header<bgcolor=0xA0A0A0,name="GPT Header">;
    local int i=0;
    //010 editor doesnt support an array of strings :/
    local int colors[6]={0x000080, 0x008000,0x800080,0x808000,0x008080,0x404040};
    for(i=0;i<128 ;i++){
        int64 temp <hidden=true>;
        if(temp==0){
            FSkip(120);
        }else{
            FSkip(-8);
            SetBackColor(colors[i%6]);
            GPT_Partition_Entry part;
        }
        SetBackColor(0xffffffff);
    } 
}



local int64 volume_used_space = 0;


typedef struct (int64 offset) {
    //local uint64 offset = offset;
    byte Bootable <format=hex, fgcolor=cRed, comment=isbootable, name="Bootable Flag">;
    byte chs_start[3] <format=binary, fgcolor=cGreen, name="Start CHS Bytes ">;
    local ushort start_cyl =(uchar)chs_start[1]/64*256+(uchar)chs_start[2];
    local ushort start_head = (uchar)chs_start[0];
    local ushort start_sector =(uchar)chs_start[1]%64;
    ubyte type <fgcolor=cLtBlue, format=hex, comment=get_type, name="Partition Type">;
    byte chs_end[3] <format=binary, fgcolor=cLtGreen, name="End CHS Bytes ">;
    local ushort end_cyl =(uchar)chs_end[1]/64*256+(uchar)chs_end[2];
    local ushort end_head = (uchar)chs_end[0];
    local ushort end_sector =(uchar)chs_end[1]%64;
    uint start_sector <fgcolor=cDkYellow, name="Start Sector">;
    local uint64 start_sector_bytes = start_sector*512;
    local uint64 start_sector_absolute = start_sector + offset/512;
    local uint64 start_sector_absolute_bytes =start_sector_absolute*512;
    uint part_size<fgcolor=cPurple, name="Partiton Size (Sectors)">;
    local uint64 part_size_bytes = part_size*512;
    if (type != 0x05){
        volume_used_space += part_size_bytes;
    }
} MBR_Partition ;

string isbootable (byte b){
    if(b == 0x80){
         return "Yes";
    }
    else {
        return "No";
    }
}

string get_type (byte b){
    switch(b){
        case 0x00 : return "Empty";
        case 0x01 : return "FAT12";
        case 0x04 : return "FAT16 <32M";
        case 0x05 : return "Extended";
        case 0x06 : return "FAT16";
        case 0x07 : return "HPFS/NTFS";
        case 0x0B : return "FAT32";
        case 0x0C : return "FAT32 LB";
        case 0x0D : return "FAT16 LB";
        case 0x82 : return "Linux swap";
        case 0x83 : return "Linux";
        case 0xee : return "GPT";
        default   : return "Unknown";
    }
}
string get_type2 (struct p){
    switch(p.type){
        case 0x00 : return "Empty";
        case 0x01 : return "FAT12";
        case 0x04 : return "FAT16 <32M";
        case 0x05 : return "Extended";
        case 0x06 : return "FAT16";
        case 0x07 : return "HPFS/NTFS";
        case 0x0B : return "FAT32";
        case 0x0C : return "FAT32 LB";
        case 0x0D : return "FAT16 LB";
        case 0x82 : return "Linux swap";
        case 0x83 : return "Linux";
        case 0xee : return "GPT";
        default   : return "Unknown";
    }
}

void ParseMBR(int64 offset, int64 part_offset){
    if(offset==0 && part_offset==0){
    FSeek(440);
    uint Disk_sig <bgcolor=cLtRed>;
    }
    volume_used_space +=512;
    FSeek(offset + part_offset+ 446);

    SetBackColor(0x6f7554);
    FSkip(0x04);
    byte skip1<hidden=true>;
    FSkip(-0x05);
    if(skip1 == 0x00){
        MBR_Partition part1(offset+ part_offset)<hidden=true>;
    }else if (skip1==0x05){
        MBR_Partition part1(offset+ part_offset)<comment="Extended", name="Partiton Entry 1 ">;
    }else{
        MBR_Partition part1(offset+ part_offset)<name="Partiton Entry 1 ">;
    }

    SetBackColor(0x597554);
    FSkip(0x04);
    byte skip2<hidden=true>;;
    FSkip(-0x05);
    if(skip2 == 0x00){
        MBR_Partition part2(offset+ part_offset)<hidden=true>;
    }else if (skip2==0x05){
        MBR_Partition part2(offset+ part_offset)<comment="Extended", name="Partiton Entry 2 ">;
    }else{
        MBR_Partition part2(offset+ part_offset)<name="Partiton Entry 2 ">;
    }

    SetBackColor(0x547568);
    FSkip(0x04);
    byte skip3 <hidden=true>;
    FSkip(-0x05);
    if(skip3 == 0x00){
        MBR_Partition part3(offset+ part_offset)<hidden=true>;
    }else if (skip3==0x05){
        MBR_Partition part3(offset+ part_offset)<comment="Extended", name="Partiton Entry 3 ">;
    }else{
        MBR_Partition part3(offset+ part_offset)<name="Partiton Entry 3 ">;
    }

    
    SetBackColor(0x547275);
    FSkip(0x04);
    byte skip4<hidden=true>;
    FSkip(-0x05);
    if(skip4 == 0x00){
        MBR_Partition part4(offset+ part_offset)<hidden=true>;
    }else if (skip4==0x05){
        MBR_Partition part4(offset+ part_offset)<comment="Extended", name="Partiton Entry 4 ">;
    }else{
        MBR_Partition part4(offset+ part_offset)<name="Partiton Entry 4 ">;
    }

    SetBackColor(cNone);
    if(part1.type==0x05){ParseMBR(offset,part1.start_sector_bytes);}
    if(part2.type==0x05){ParseMBR(offset,part2.start_sector_bytes);}
    if(part3.type==0x05){ParseMBR(offset,part3.start_sector_bytes);}
    if(part4.type==0x05){ParseMBR(offset,part4.start_sector_bytes);}

    if(part1.type==0xee){readGPT(offset+part1.start_sector_bytes);}
    if(part2.type==0xee){readGPT(offset+part2.start_sector_bytes);}
    if(part3.type==0xee){readGPT(offset+part3.start_sector_bytes);}
    if(part4.type==0xee){readGPT(offset+part4.start_sector_bytes);}
}


LittleEndian();
ParseMBR(0,0);





/*

//this is garbage dont look iat it :(


FSeek(440);
uint Disk_sig <bgcolor=cLtRed>;
FSeek(446);
volume_used_space +=512;

SetBackColor(0x6f7554);
FSkip(0x04);
byte skip1<hidden=true>;
FSkip(-0x05);
if(skip1 == 0x00){
    MBR_Partition part1(0)<hidden=true>;
}else if (skip1==0x05){
    MBR_Partition part1(0)<comment="Extended", name="Partiton Entry 1 ">;
}else{
    MBR_Partition part1(0)<name="Partiton Entry 1 ">;
}

SetBackColor(0x597554);
FSkip(0x04);
byte skip2<hidden=true>;;
FSkip(-0x05);
if(skip2 == 0x00){
    MBR_Partition part2(0)<hidden=true>;
}else if (skip2==0x05){
    MBR_Partition part2(0)<comment="Extended", name="Partiton Entry 2 ">;
}else{
    MBR_Partition part2(0)<name="Partiton Entry 2 ">;
}

SetBackColor(0x547568);
FSkip(0x04);
byte skip3 <hidden=true>;
FSkip(-0x05);
if(skip3 == 0x00){
    MBR_Partition part3(0)<hidden=true>;
}else if (skip3==0x05){
    MBR_Partition part3(0)<comment="Extended", name="Partiton Entry 3 ">;
}else{
    MBR_Partition part3(0)<name="Partiton Entry 3 ">;
}

SetBackColor(0x547275);
FSkip(0x04);
byte skip4<hidden=true>;
FSkip(-0x05);
if(skip4 == 0x00){
    MBR_Partition part4(0)<hidden=true>;
}else if (skip4==0x05){
    MBR_Partition part4(0)<comment="Extended", name="Partiton Entry 4 ">;
}else{
    MBR_Partition part4(0)<name="Partiton Entry 4 ">;
}

SetBackColor(cNone);
if(part1.type==5){ParseMBR(part1.start_sector_bytes,0);}
if(part2.type==5){ParseMBR(part2.start_sector_bytes,0);}
if(part3.type==5){ParseMBR(part3.start_sector_bytes,0);}
if(part4.type==5){ParseMBR(part4.start_sector_bytes,0);}
*/

FSeek(FileSize()-512);
string end;
local int64 file_size = FileSize();
if(end=="conectix"){
    file_size-= 512;
}

SetBackColor(cRed);
FSkip(512);
local int64 wasted_space = file_size - volume_used_space;